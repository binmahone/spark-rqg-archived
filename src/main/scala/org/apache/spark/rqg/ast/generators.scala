package org.apache.spark.rqg.ast

import org.apache.spark.rqg.{DataType, StructType, ArrayType, MapType, DecimalType, GenericNamedType}
import org.apache.spark.rqg.ast.expressions.Expression

/**
 * All TreeNode is generated by an companion object class which extends one of generators.
 *
 * This `generator` class is used to make sure TreeNode generator has same apply function and
 * we can easily random choose a generator from an Array. For example:
 *
 * val choices = Array(ConstantGenerator, ColumnGenerator, ExpressionGenerator)
 * RandomUtil.choose(choices).apply(querySession, parent)
 */
trait Generator[T]

/**
 * Common Generator trait, most TreeNode generator extends this
 */
trait TreeNodeGenerator[T] extends Generator[T] {
  def apply(querySession: QueryContext, parent: Option[TreeNode]): T
}

/**
 * SubQuery needs to have a return type. Therefore, NestedQuery and Select Clause
 * should extends this class
 */
trait TreeNodeWithParent[T] extends Generator[T] {
  def apply(querySession: QueryContext, parent: Option[TreeNode], requiredDataType: Option[DataType[_]]): T
}

/**
 * All kinds of RelationPrimary generator extends this, such as:
 * TableReference, AliasedQuery, FunctionTable. For now, we only support TableReference
 */
trait RelationPrimaryGenerator[T] extends Generator[T] {
  def apply(querySession: QueryContext, parent: Option[TreeNode]): T
}

/**
 * All kinds of Expression generator extends this, such as:
 * BooleanExpression, ValueExpression, PrimaryExpression. This generator has more parameters than
 * others.
 */
trait ExpressionGenerator[T] extends Generator[T] {
  /**
   * If a generator is possible to generate a primitive expression, like Constant, ColumnReference,
   * then return true. For example, ValueExpression -> PrimaryExpression -> Constant (return true)
   * LogicalNot can only generate "NOT xxx" which is nested expression (return false)
   */
  def canGeneratePrimitive: Boolean

  /**
   * If a generator is possible to generate a relational expression, like comparison, return true.
   */
  def canGenerateRelational: Boolean

  /**
   *  If a generator is possible to generate a aggregation function. like count, sum
   */
  def canGenerateAggFunc: Boolean

  /**
   * If a generator is possible to generat a nested expression, like LogicalBinary, return true.
   * For example, ColumnReference should return false
   */
  def canGenerateNested: Boolean

  /**
   * Possible data types a generator can return. For nested or parameterized types, this is
   * technically a list of "abstract" types: for example, if `StructType` appears in this list,
   * it means _any_ struct type is a possible data type. Similarly, if `DecimalType` appears in this
   * list, the decimal is allowed to have any randomly generated precision or scale.
   *
   * Note: The only exception to this is ColumnReference, which returns concrete types. This
   * should be refactored into a different function.
   */
  def possibleDataTypes(queryContext: QueryContext): Array[DataType[_]]

  /**
   * @param requiredDataType means the generated expression should return this data type
   * @param isLast means if this is the last expression in a nested expression tree.
   *               This parameter used to make sure we can generate enough nested expression
   *               For example, in below case, when generating expr2, isLast = true. and if we need
   *               more nested expression, expr2 can't be a primitive one
   *                          AND
   *                         /   \
   *                     expr1  expr2
   */
  def apply(
      querySession: QueryContext,
      parent: Option[TreeNode],
      requiredDataType: DataType[_],
      isLast: Boolean): T

  /**
   * Given a required concrete data type and a list of expression generators, returns a filtered list
   * of expressions generators that can produce an expression of the required type.
   *
   * @param querySession the query context
   * @param requiredDataType the required concrete data type, e.g., 'int' or 'struct<int,long>'.
   * @param choices possible expression generators, e.g., `Array(FunctionCall, Constant)`.
   * @return filtered list of generators from `choices`. Each generator in the list can generate an
   *         expression with type `requiredDataType`.
   */
  def filterChoicesForRequiredType[T](
      querySession: QueryContext,
      requiredDataType: DataType[_],
      choices: Seq[ExpressionGenerator[_ <: T]]): Seq[ExpressionGenerator[_ <: T]] = {
    choices.filter(expr =>
      expr.possibleDataTypes(querySession).exists {
        // Type matches exactly.
        case ty if requiredDataType.sameType(ty) => true
        // Generic types can be resolved to any type.
        case _: GenericNamedType => true
        // For parameterized types, check if the expression can generate a type of that kind.
        case ty if requiredDataType.isInstanceOf[StructType] => ty.isInstanceOf[StructType]
        case ty if requiredDataType.isInstanceOf[ArrayType] => ty.isInstanceOf[ArrayType]
        case ty if requiredDataType.isInstanceOf[MapType] => ty.isInstanceOf[MapType]
        case ty if requiredDataType.isInstanceOf[DecimalType] => ty.isInstanceOf[DecimalType]
        case _ => false
      }
    )
  }
}

/**
 * Similar to ExpressionGenerator, but requiredDataType is not a return type since predicate is
 * not actually an expression
 */
trait PredicateGenerator[T] extends Generator[T] {
  def apply(querySession: QueryContext, parent: Option[TreeNode], requiredDataType: DataType[_]): T
}
